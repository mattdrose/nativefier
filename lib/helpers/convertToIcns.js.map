{"version":3,"sources":["helpers/convertToIcns.js"],"names":["isOSX","setGracefulCleanup","PNG_TO_ICNS_BIN_PATH","join","__dirname","convertToIcns","pngSrc","icnsDest","callback","exec","silent","exitCode","stdOut","stdError","includes","convertToIcnsTmp","tempIconDirObj","dirSync","unsafeCleanup","tempIconDirPath","name"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;;;IAEQA,K,qBAAAA,K;;AACR,cAAIC,kBAAJ;;AAEA,IAAMC,uBAAuB,eAAKC,IAAL,CAAUC,SAAV,EAAqB,OAArB,EAA8B,mBAA9B,CAA7B;;AAEA;;;;;;AAMA;;;;;;AAMA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmD;AACjD,MAAI,CAACR,OAAL,EAAc;AACZQ,aAAS,+CAAT,EAA0DF,MAA1D;AACA;AACD;;AAED,oBAAMG,IAAN,CAAY,GAAEP,oBAAqB,IAAGI,MAAO,IAAGC,QAAS,EAAzD,EAA4D,EAAEG,QAAQ,IAAV,EAA5D,EAA8E,UAACC,QAAD,EAAWC,MAAX,EAAmBC,QAAnB,EAAgC;AAC5G,QAAID,OAAOE,QAAP,CAAgB,oBAAhB,KAAyCH,QAA7C,EAAuD;AACrD,UAAIA,QAAJ,EAAc;AACZH,iBAAS;AACPI,gBADO;AAEPC;AAFO,SAAT,EAGGP,MAHH;AAIA;AACD;;AAEDE,eAASI,MAAT,EAAiBN,MAAjB;AACA;AACD;;AAEDE,aAAS,IAAT,EAAeD,QAAf;AACD,GAfD;AAgBD;;AAED;;;;;AAKA,SAASQ,gBAAT,CAA0BT,MAA1B,EAAkCE,QAAlC,EAA4C;AAC1C,MAAMQ,iBAAiB,cAAIC,OAAJ,CAAY,EAAEC,eAAe,IAAjB,EAAZ,CAAvB;AACA,MAAMC,kBAAkBH,eAAeI,IAAvC;AACAf,gBAAcC,MAAd,EAAuB,GAAEa,eAAgB,YAAzC,EAAsDX,QAAtD;AACD;;kBAEcO,gB","file":"convertToIcns.js","sourcesContent":["import shell from 'shelljs';\nimport path from 'path';\nimport tmp from 'tmp';\nimport helpers from './helpers';\n\nconst { isOSX } = helpers;\ntmp.setGracefulCleanup();\n\nconst PNG_TO_ICNS_BIN_PATH = path.join(__dirname, '../..', 'bin/convertToIcns');\n\n/**\n * @callback pngToIcnsCallback\n * @param error\n * @param {string} icnsDest If error, will return the original png src\n */\n\n/**\n *\n * @param {string} pngSrc\n * @param {string} icnsDest\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcns(pngSrc, icnsDest, callback) {\n  if (!isOSX()) {\n    callback('OSX is required to convert .png to .icns icon', pngSrc);\n    return;\n  }\n\n  shell.exec(`${PNG_TO_ICNS_BIN_PATH} ${pngSrc} ${icnsDest}`, { silent: true }, (exitCode, stdOut, stdError) => {\n    if (stdOut.includes('icon.iconset:error') || exitCode) {\n      if (exitCode) {\n        callback({\n          stdOut,\n          stdError,\n        }, pngSrc);\n        return;\n      }\n\n      callback(stdOut, pngSrc);\n      return;\n    }\n\n    callback(null, icnsDest);\n  });\n}\n\n/**\n * Converts the png to a temporary directory which will be cleaned up on process exit\n * @param {string} pngSrc\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcnsTmp(pngSrc, callback) {\n  const tempIconDirObj = tmp.dirSync({ unsafeCleanup: true });\n  const tempIconDirPath = tempIconDirObj.name;\n  convertToIcns(pngSrc, `${tempIconDirPath}/icon.icns`, callback);\n}\n\nexport default convertToIcnsTmp;\n"]}